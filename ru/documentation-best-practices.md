_Резюме: обсудим когда нужна или не нужна документация разного рода (JavaDocs, общая проектная документация) и как на это влияют тенденции из области гибких методологий (а конкретно - Scrum)._

#### JavaDocs
Интересно, что прочитав книгу [Clean Code](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) Robert'a Martin'a, единственное, что запоминает _подавляющее большинство_ читающих - не нужно писать документацию. Их код не становится чище, элегантней и понятней. Зато теперь у них есть оправдание не писать JavaDocs! Как удобно.

Как и большинство хороший вещей, по-моему книга Clean Code не лишена ошибок, одна из них - это глава о JavaDocs. На первый взгляд в ней ничего криминального нет, все написано разумно и логично: предполагается, что разработчики будут писать настолько понятный код, что потребности в JavaDocs просто отпадут. Однако на своем опыте я встречал лишь _одного-единственного человека_(здесь много знаков восклицания), который писал бы красивый и достаточно понятный код (это я не про себя :)). И даже его код все равно нуждался в дополнительном разъяснении. 

**Докумнетирование намерений**. Принципиальная ошибка адептов без-комментости в том, что они считают будто документировать нужно код. На самом деле это не самое главное в комментариях, что делает тот же метод можно понять из самого кода. Я не говорю, что это всегда просто, но это по крайней мере возможно. А вот что бывает невозможно понять - это намерения человека: почему было сделано так, а не иначе? Зачем вообще это делалось? Вот вам пример метода: 
```java
    public JCUser getByUsername(String username) {
        List<JCUser> users = session().createCriteria(JCUser.class)
                .add(Restrictions.eq("username", username).ignoreCase()).list();
        if (users.size() == 1) {
            return users.get(0);
        } else {
            for (JCUser user : users) {
                if (user.getUsername().equals(username)) {
                    return user;
                }
            }
            return null;
        }
    }
```
Итак, что нам известно:
* Метод ищет пользователя по имени. Это ясно из имени.
* Запрос может вернуть несколько(!) пользователей. Это чуть сложней понять, но в принципе логично. Это бы означало, что пользователи могут быть иметь одно и то же имя, которое отличается лишь регистром. В принципе все понятно.

Однако немного посмотрев на код проекта мы понимаем, что приложение проверяет имя пользователя во время регистрации и не позволит создать двух одинаковых пользователей, отличающихся лишь регистром. И вот теперь вы будете долго чесать затылок - знал ли разработчик больше, чем вы, или же просто сглупил? Меня постоянно мучит такой вопрос когда я вижу странный код. И вот тут-то и было бы полезно описать намерения - а дело все в том, что изначально приложение все-таки поддерживало пользователей с одним именем и разным регистром и на прод окружении уже есть такие пользователи и такая проверка была введена как раз для того, чтоб эти ранние пользователи могли нормально залогиниться. Однако разработчик решил, что документировать этот кусок не нужно - ему-то ведь было все понятно. И всем в проекте на тот момент было все понятно. Никто только не подумал про новичков, которые придя в проект будут так же чесать репу, как это делали вы только что.

**Документирование доменной модели**. Сколько раз приходилось наблюдать классы с жуткими ненужными комментариями:
```java
  /**
   * Sets the name.
   * @name the name
   */
  public void setName(String name) {
    this.name = name;
  }
```
Конечно о вреде таких комментариев не поспоришь, но все можно устроить намного лучше. Ваша доменная модель - это сердце системы, она является проекцией реального мира на код. Так вот, доменная модель большинству разработчиков является очень элементарной штукой, которую документировать ну совсем уж некак. Ну что здесь сказать - имя оно и в африке имя. Однако предметной области тоже нужно обучаться и далеко не для всякого новичка в вашем проекте будет понятно что это поле значит, где оно применятся и в каких целях, какие его особенности. Интересно, что независимо от сложности предметной области, разработчики одинаково наплевательски относятся к документированию доменной модели. Но все ли знают о чем здесь речь:
```java
public class Futures {
  private BigDecimal strikePrice;
  private int amountOfLots;
  private DateTime expiryDate;
  private BuyCall buyCall;
}
```
Те, кто работал когда-либо с инвестиционными банками, возможно, возмутиться что тут непонятного, однако для новичков это совсем не тривиальные вещи. И для того, чтоб в ваш проект вы могли быстро ввести нового человека, вам обязательно нужно документировать _что_ значит каждое поле, _как_ оно вычисляется, _где_ можно найти об этом более детальную информацию. Однако так не делают и в в инвестиционных банках давно не удивляются, что человек, проработавший полгода на проекте до сих пор не особо осознает как с ним работать. Они давно считают, что это норма и не понимают как можно иначе.

Это относится и к другим областям, та же медицина к примеру. Да даже тот же элментарный username в обычном веб приложении - имя имени рознь, некоторые из них уникальные, другие - нет; одни можно изменять - другие нет; одни завязаны на внешние системы - другие локальны. Поэтому не ленитесь подробно описывать свою доменную модель.

**Ссылки на багтрекеры**. Многие решения, которые были приняты в той или иной задаче в частенько забываются, либо приходят новые люди и тоже не понимают ни решения, ни расспросить уволенного прежде сотрудника не могут. Поэтому крайне полезно в коде оставлять ссылки на задачи (например, в JIRA), которые послужили причиной написания того или иного класса либо метода. Это поможет отследить идеи и _уточнить требования_(!) в будущем. Можно конечно и в commit message описывать номер задачи, однако класс затем могут и форматировать, и видоизменять - не всегда легко найти откуда ноги растут.

**Документирование реализации**. Здесь вопрос стоит чуть тоньше. На самом деле при выбранном 


 The older a comment is, and the farther away it is from the code it describes, the more likely it is to be just plain wrong.

