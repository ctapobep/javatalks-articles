_Резюме: обсудим когда нужна или не нужна документация разного рода (JavaDocs, общая проектная документация) и как на это влияют тенденции из области гибких методологий (а конкретно - Scrum)._

#### JavaDocs
Интересно, что прочитав книгу [Clean Code](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) Robert'a Martin'a, единственное, что запоминает _подавляющее большинство_ читающих - не нужно писать документацию. Их код не становится чище, элегантней и понятней. Зато теперь у них есть оправдание не писать JavaDocs! Как удобно.

Как и большинство хороший вещей, по-моему книга Clean Code не лишена ошибок, одна из них - это глава о JavaDocs. На первый взгляд в ней ничего криминального нет, все написано разумно и логично: предполагается, что разработчики будут писать настолько понятный код, что потребности в JavaDocs просто отпадут. Однако на своем опыте я встречал лишь _одного-единственного человека_(здесь много знаков восклицания), который писал бы красивый и достаточно понятный код (это я не про себя :)). И даже его код все равно нуждался в дополнительном разъяснении. 

**Намеренья нельзя понять по коду, их нужно документировать**. Принципиальная ошибка адептов без-комментости в том, что они считают будто документировать нужно код. На самом деле это не самое главное в комментариях: что делает тот же метод можно понять из самого кода. Я не говорю, что это всегда просто, но это по крайней мере возможно. А вот что бывает невозможно понять - это намерения человека: почему было сделано так, а не иначе? Зачем вообще это делалось? Вот вам пример метода: 
```java
    public JCUser getByUsername(String username) {
        List<JCUser> users = session().createCriteria(JCUser.class)
                .add(Restrictions.eq("username", username).ignoreCase()).list();
        if (users.size() == 1) {
            return users.get(0);
        } else {
            for (JCUser user : users) {
                if (user.getUsername().equals(username)) {
                    return user;
                }
            }
            return null;
        }
    }
```
Итак, что нам известно:
* Метод ищет пользователя по имени. Это ясно из наименования метода.
* Запрос может вернуть несколько(!) пользователей, понятно из самого кода. Это бы означало, что пользователи могут иметь одно и то же имя, которое отличается лишь регистром. В принципе все понятно.

Однако немного посмотрев на код проекта мы понимаем, что приложение проверяет имя пользователя во время регистрации и не позволит создать двух одинаковых пользователей, отличающихся лишь регистром. И вот теперь вы будете долго чесать затылок - знал ли разработчик больше, чем вы, или же просто сглупил? А может просто база ищет строки не обращая внимание на регистр? Да нет, в схеме указано `COLLATE utf8_bin`, такие строки будут регистрозависимыми во время поиска. Какой из этих вариантов вы выберете и откуда будете знать сделали ли вы выбор верно? Меня постоянно мучат такие вопросы когда вижу странный код. И вот тут-то и было бы полезно описать намерения - а дело все в том, что изначально приложение все-таки поддерживало пользователей с одним именем и разным регистром, и на прод окружении уже есть такие пользователи и такая проверка была введена как раз для того, чтоб эти ранние пользователи могли нормально залогиниться. Однако разработчик решил, что документировать этот кусок не нужно - ему-то ведь было все понятно. И всем в проекте на тот момент было все понятно. Никто только не подумал про новичков, которые придя в проект будут так же чесать репу, как это делали вы только что. Давайте исправим ситуацию добавив JavaDocs:
```java
    /**
     * Get {@link JCUser} with corresponding username ignoring case. If there are several identical usernames that
     * differ only by letter case, we check exact match among them. This is done due to historical reasons - in the
     * early releases users with the same username were allowed if they had letters in different cases,
     * but afterwards it was decided that if user `Vasia` is registered, then another new user shouldn't be allowed
     * to register with `vAsia` username. This decision was made too late and by that time we had such users on the
     * production already, thus this check for exact match was introduced.
     *
     * @return {@link JCUser} with given username or null if not found
     * @see <a href="http://jira.jtalks.org/browse/JC-1163">JC-1163</a>
     */
    public JCUser getByUsername(String username){}
```

**Документирование доменной модели позволяет описать предметную область**. Сколько раз приходилось наблюдать классы с жуткими ненужными комментариями:
```java
  /**
   * Sets the name.
   * @name the name
   */
  public void setName(String name) {
    this.name = name;
  }
```
Конечно о вреде таких комментариев не поспоришь, но все можно устроить намного лучше. Ваша доменная модель - это сердце системы, она является проекцией реального мира на код. Так вот, доменная модель большинству разработчиков является очень элементарной штукой, которую документировать ну совсем уж некак. Ну что здесь сказать - имя оно и в африке имя. Однако предметной области тоже нужно обучаться и далеко не для всякого новичка в вашем проекте будет понятно что это поле значит, где оно применятся и в каких целях, какие его особенности. Интересно, что независимо от сложности предметной области, разработчики одинаково наплевательски относятся к документированию доменной модели. Но все ли знают о чем здесь речь:
```java
public class Futures {
  private BigDecimal strikePrice;
  private int amountOfLots;
  private DateTime expiryDate;
  private BuyCall buyCall;
}
```
Те, кто работал когда-либо с инвестиционными банками, возможно, возмутиться что тут непонятного, однако для новичков это совсем не тривиальные вещи. И для того, чтоб в ваш проект вы могли быстро ввести нового человека, вам обязательно нужно документировать _что_ значит каждое поле, _как_ оно вычисляется, _где_ можно найти об этом более детальную информацию. Однако так не делают и в в инвестиционных банках давно не удивляются, что человек, проработавший полгода на проекте до сих пор не особо осознает как с ним работать. Они давно считают, что это норма и не понимают как можно иначе.

Это относится и к другим областям, та же медицина к примеру. Да даже тот же элментарный username в обычном веб приложении - имя имени рознь, некоторые из них уникальные, другие - нет; одни можно изменять - другие нет; одни завязаны на внешние системы - другие локальны. Поэтому не ленитесь подробно описывать свою доменную модель.

**Ссылки на багтрекеры помогают найти историческую информацию**. Многие решения, которые были приняты в той или иной задаче, частенько забываются, либо приходят новые люди и тоже не понимают ни решения, ни расспросить уволенного прежде сотрудника не могут. Поэтому крайне полезно в коде оставлять ссылки на задачи (например, в JIRA), которые послужили причиной написания того или иного класса либо метода. Это поможет отследить идеи и _уточнить требования_(!) в будущем. Можно конечно и в commit message описывать номер задачи, однако класс затем могут и форматировать, и видоизменять - не всегда легко найти откуда ноги растут.

**Документирование реализации**. Здесь вопрос стоит чуть тоньше. Как уже было оговорено раньше - реализацию хоть иногда и сложно понять, однако возможно.

**Документирование требований**. Обычно подходы следующие:
* Требования не документируют. Это позволит не замарачиваться насчет лишнего в начале разработки, но сделает проблемой поддержку продукта. QA не будут иметь требований чтоб проверить продукт. Надеяться на то, что все и так будет логично и все всё поймут, не стоит - у каждого своя логика и частенько между QA и Dev командами из-за этого возникают разногласия и споры. 
* Требования описаны в баг трекере. Возможная ситуация, проблема начнет показывать себя чуть позже, когда существует много задач на одну и ту же тематику. И тогда трудно бывает сопоставить эти куски, чтоб получить единое целое. Да и продукт эволюционирует - сначала нужно было так, а затем решили эдак. И одна задача говорит одно, а другая - совсем противоположное. В таком случае можно запутаться. Еще один минус - очень не многие умеют правильно пользоваться баг трекерами: проставлять статусы, комментировать, связывать задачи. А если этого не делать правильно и систематично, то проследить требования сделается невозможным.
* Требования описываются на wiki.


 The older a comment is, and the farther away it is from the code it describes, the more likely it is to be just plain wrong.

