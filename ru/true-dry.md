Оглядываясь на многие проекты, стало понятно, что многие разработчики и архитекторы, даже очень опытные, не понимают на самом деле когда и как следует применять Don't Repeat Yourself Principle (DRY Principle). У меня тоже была такая проблема, однако потерпая неудачу за неудачей в проектах, таки обрисовалась какая-то картина того как же все-таки _правильно_ избегать дублирования. Толчком к прозрению стало общение с Sam'ом Newman'ом из ThoughtWorks, и его доклад Rapid Releases, за что ему большое спасибо.

Главное, с чем нужно для начала определиться - у медали есть обратная сторона. Следуя DRY, мы имеем следующие положительные улучшения:
 - Изменения в одном месте подхватываются сразу во всем проекте(ах). Положительным есть то, что нам не нужно во всех дублирующих местах делать одни и те же изменеия. Это также снижает риск того, что мы пропустим пару таких мест.
 - Если существует всем понятное место, где логика уже написана, вероятность того, что ее будут реализовывать снова изобретая старые добрые велосипеды, снижается

Подробней о DRY и в общем о SOLID OOD принципах можете узнать из [одноименной презентации](http://javatalks.ru/topics/18502). Однако мы мало говорим о недостатках таких принципов, и это главная тема на сегодня. Начнем с маломасштабных примеров:

####Уровень классов

  - Однако нужно ли это всегда? Ведь это какое-то глобальное состояние или метод, которые могут _неожиданно_ затронуть то, что не должно было быть затронуто
  - Также негативным эффектом может быть изменение общих модулей, на которые ссылаются несколько приложений. Ведь одна команда может не поспевать и иметь более приоритетные задачи.
  - Изменение общих модулей трудоемко, они находятся в других SCM репозиториях, их нужно релизить прежде чем их можно использовать. Это совсем не одно и то же, что изменять код в своем же проекте.
  - Изменение общих зависимостей между проектами может привести к тому, что и релизить их нужно одновременно